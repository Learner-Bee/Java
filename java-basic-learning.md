#java教程
##重点知识：
###1 一个java源文件中最多有一个public类，且该public类名和文件名必须相同，否则无法编译；一个源文件中可以不包含public类(因为每个编译单元即文件都只能有一个公开的接口，这个接口就由public表示)；main()不是必须放在public类中才能运行的
    
###2 由static修饰的静态方法，只能引用静态方法。非静态方法，可以引用静态方法和非静态方法和变量
###3 static修饰的变量和方法，可以直接通过类名来访问，不用创建对象来引用
###4 访问修饰符public和private、protected修饰变量时，只能修饰全局变量。
###5 方法内的变量的作用域只在该方法中，已经是私有的了，所以不用访问修饰符修饰
###6 public修饰的作用域为该类以及包内或者其他包都可以访问
###7 private作用域为只能该类中访问。子孙类不能访问
###8 protected作用域是包内、类中、其他类。不能被其他包访问
###9 父类中的有参构造方法，在子类中必须用super(相应参数)来调用构造方法
###10 子类执行构造器前，必须先初始化父类中的成员变量,然后再是构造器
##java简介
java分为三个体系：  

* JavaSE（J2SE）：Java平台标准版
* JavaEE（J2EE）：Java平台企业版
* JavaME（J2ME）：Java平台微型版
###主要特性
 
* Java语言是简单的
* Java语言是面向对象的
* 分布式的
* 健壮的
* 安全的
* 体系结构中立的
* 可移植的
* 解释型的
* 高性能的
* 多线程的
* 动态的
##Java基础语法

* 对象：对象是类的一个实例，有状态和行为
* 类：类是一个模板
* 方法：就是行为
* 实例变量：每个对象都有独立的实例变量，对象的状态由实例变量的值决定
###基本语法

* 大小写敏感
* 类名：**类名首字母应该大写**。若类名由多个单次组成，那每个单次首字母都应大写，如：MyFirstJavaClass
* 方法名：所有**方法名都应由小写字母开头**。若含有多个单次，则后面的每个单次首字母大写。
* 源文件名：必须和类名相同。文件名后缀.java（文件名和类名不相同会编译错误）
* 主方法入口：所有的java程序由public static void main (String args[])方法开始执行
###Java标识符
类名、变量、方法都叫标识符

* 所有标识符必须由**字母（A-Z或a-z）、$、下划线（_）3种**可能开始
* 关键字不能用作标识符
* 大小写敏感
###接口
在Java中，接口可以理解为对象相互通信的协议。接口在继承中扮演着重要角色。  
接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类
##Java对象与类
###Java中的类
一个类可以包含以下类型变量

* 局部变量：在方法、构造方法、语句块中定义的变量。变量声明初始化在方法中，方法结束后，变量会自动销毁
* 成员变量：定义在类中，方法体之外。成员变量在创建对象时实例化
* 类变量：也声明在类中、方法外，但必须声明为static类型
###构造方法
每个类都有构造方法。如果没有显示地为类定义构造方法，Java编译器会为该类提供一个默认构造方法  
在创建一个对象的时候，至少要调用一个构造方法。**构造方法的名称必须与类名相同**，一个类可以有多个构造方法  
例：  
public class Puppy{  
 public Puppay(){  
}  
public Puppy(String name){  
//  这个构造器仅有一个参数：name   
}  
}  
###创建对象
使用关键字new创建一个对象。步骤：  

* 声明：声明对象，包括对象名和类型
* 实例化：使用关键字new来创建一个对象
* 初始化：创建对象时，会调用构造方法初始化对象  

### 源文件声明规则

* 一个源文件只能有一个public类
* 一个源文件可以有多个非public类
* 源文件名应和public类名相同
* 若类定义在包中，package语句应在源文件首行
* 若源文件中包含import语句，应放在package和类定义之间
###Java包
包主要用来对接口和类进行分类  
##Java基本数据类型
java两大数据类型：  

* 内置数据类型
* 引用数据类型
###内置数据类型
java提供八种数据类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，一种布尔型。  

* byte 
* short
* int
* long
* float
* double
* char
* boolean ：两个值true 、false。默认是false
###引用类型

* 引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定类型。如Employee和Puppy。
* 对象、数组都是引用数据类型
* 所有引用类型的默认值都是null
###Java常量
使用final修饰常量，声明方式和变量类似：  final double PI=3.1415926   
**注：**常量名可以用小写，但为了便于识别，通常使用大写字母表示常量  
###自动类型装换
低------------>高  
byte,short,char->int->long->float->double  
数据类型转换必须满足：  

* 不能对boolean类型进行类型转换
* 不能把对象类型转换成不相关类的对象
* 把容量大的类型转为容量小的类型时必须使用强制类型转换
*  **浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入**
* 转换过程可能导致溢出或损失精度：int i=8;byte b =(byte)i;
##Java变量类型
java语言支持的变量类型有：

* 类变量：独立于方法之外的变量，用static修饰
* 实例变量：独立于方法之外的变量，不过没有static修饰
* 局部变量：类的方法中的变量  

例：
public class Variable{  
 static int a=0;  //类变量  
 String str="hello world" //实例变量  
public void method(){  
 int b=1;//局部变量  
}  
}  
###Java局部变量

* 局部变量声明在方法、构造方法、语句块中
* 在方法、构造方法、语句块中被执行时创建，当被执行后，变量将会被销毁
* 访问修饰符不能用于局部变量
* 只有在声明他的地方可见
* 在栈上分配的
* 局部变量没有默认值。所以**局部变量被声明后，必须初始化后才可使用**

###实例变量（全局变量、成员变量）

* 声明在一个类中，但在方法、构造方法、语句块之外
* 当一个对象被实例化后，每个实例变量的值就跟着确定
* 实例变量在对象创建时创建，在对象被销毁时销毁
* 实例变量的值应该至少被一个方法、构造方法、语句块引用，使得外部能通过这些方式获取实例变量的信息
* 实例变量可以声明在使用前或使用后
* 访问修饰符可以修饰实例变量
* 实例变量对于类中的方法、构造方法、语句块是可见的，一般应该把实例变量设为私有，通过使用访问修饰符可以使实例变量对子类可见
* 实例变量具有默认值。数值型变量的默认值是0，布尔型变量默认值是false，引用类型变量默认值是null，变量的值可以在声明时指定，也可以在构造方法中指定
* 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：objiectReference.VariablleName
###类变量（静态变量）

* 类变量也称静态变量。在类中以static关键字声明。但必须在方法、构造方法、语句块之外。
* 无论一个类创建多少对象，类只拥有静态变量的一个拷贝
* **静态变量除了被声明为常量外很少使用**。常量是指声明为public/private,final、static类型的变量。常量初始化后不可改变
* 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量
* 静态变量在程序开始时创建，在程序结束时销毁
* **静态变量可以通过Class.VariableName方式访问**
* 静态变量被声明为public static final 类型时，变量名一般建议大写。

**全局变量和静态变量区别：**

* 静态变量属于类，该类不生产对象，通过类名就可以直接调用静态变量。
* 全局变量属于该类的对象，必须产生该类对象，才能调用全局变量 

**实例变量必须创建对象后才可以通过对象调用，静态变量可以直接使用类名来引用** 
##Java修饰符
主要分为两种：

* 访问修饰符
* 非访问修饰符
###访问控制修饰符

* public ：当前类Y；同一包内Y；子孙类Y；其他包Y
* private：当前类Y；同一包内N；子孙类N；其他包N
* protected：当前类Y；同一包内Y；子孙类Y；其他包N
* default：当前类Y；同一包Y；子孙类N；其他包N
###非访问修饰符

####static修饰符

* 静态变量：static用来声明独立于对象的静态变量。无论一个类实例化多少个对象，它的静态变量只有一个拷贝。**局部变量不能声明为静态变量**
* 静态方法：静态方法不能使用类的非静态变量。
* 对类变量和方法的访问，可以直接用classname.variablename和class.methodname方式访问
####final修饰符

* final变量

 * 可以被初始化一次。被声明为final对象的引用不能指向不同对象。但final对象里的数据可以被改变。即：final对象的引用不能改变，但是里面的值可以改变  
 * final修饰符一般和static修饰符一起使用来创建类常量
* final方法

 * 类中的final方法可以被子类继承，但是不能被子类修改
 * 声明final方法的主要目的是防止该方法中的内容被修改
* final类

 * final类不能被继承，没有类能够继承final类的任何特性
####abstract修饰符

*  抽象类

 * 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充
 * 一个类不能同时被abstract和final同时修饰。**如果一个类包含抽象方法，那么该类一定要声明为抽象类**，否则将出现编译错误
 * 抽象类可以包好抽象方法和非抽象方法
* 抽象方法

 * 抽象方法是一种没有任何实现的方法，他的具体实现由子类提供
 * 抽象方法不能被声明为final和static（1、声明为final的方法可以继承但是不能修改，但是抽象方法必须通过子类继承来重写赋予其新特性，互相矛盾2、static方法可以直接通过类来调用，但是抽象方法不能直接通过类来调用使用，矛盾）
 * 任何**继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类**
 * **如果一个类包含抽象方法，那么该类必须声明为抽象类**。抽象类可以不包含抽象方法
####synchronized修饰符

* synchronize声明的方法同一时间只能被一个线程访问
####transient修饰符

* 序列化的对象包含被transient修饰的实例变量时，java虚拟机（JVM）跳过该特定变量
* 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型
####volatile修饰符

* volatile修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。
##Java运算符

* 算术运算符：+、-、*、/、%（取模）、++（自增）、--（自减）
* 关系运算符：==、！=、>、<、>=、<=
* 位运算符:
  * &（相对应为都为1，结果为1，否则为0）
  * |（相对应为都是0，结果为0，否则为1）
  * ^(相对应位值相同，结果为0，否则为1)
  * ~（按位补运算符，翻转操作位的每一位，即0变为1,1变为0）
  * <<(按位左移。A<<2：按位左移2位) 
  * >>（按位右移）
* 逻辑运算符：
  * &&（与）（也称短路逻辑运算符，当&&左边的结果为false时，结果直接为fasle，不会执行&&右边）
  * ||（或）
  * ！（非）。
* 赋值运算符
  * =
  * += (加和赋值操作符。c+=a等价于c=c+a)、-=、*=、/=
  * (%)=(取模和赋值操作符。c%=a等价于c=c%a)
* 条件运算符：（？：）
  * variable x = (expression) ? value1 :value2
  * 判断表达式的布尔值，如果为true，x=vaule1，如果为false，x=value2
* instanceof 运算符
  * 用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）
  * （object reference variable）instanceof （class/interface type）
  * 如果运算符左侧变量所指的对象类型，是右侧类或接口的一个对象返回true
  * 如果	被比较的对象兼容于右侧类型，运算结果仍未true
##Java循环结构
###while循环
whlie（布尔表达式）{  
循环内容  
}  
**只要布尔表达式内容为true，循环就一直执行下去**
###do...while循环
do{  
代码语句  
}while（布尔表达式）；
**该循环至少执行一次**
###for循环
for（初始化；布尔表达式；更新）{  
代码块  
}  
###Java增强for循环
for（声明语句：表达式）{  
循环语句  
}

* 声明语句：声明新的局部变量。**该变量类型必须和数组元素的类型匹配**，其作用域限定在循环语句块，其值与此时数组元素值相等
* 表达式：表达式是要访问的数组名，或者是返回值为数组的方法
###break关键字

* break主要用在循环语句或者switch语句中，用来跳出整个语句块
* break跳出本层循环，停止下面的循环，继续执行循环外的语句
###continue关键字

* 作用是让程序立刻跳转到下一次循环迭代，停止执行continue后面的语句，而直接执行下次循环
##Java分支结构
###switch
switch(expression){  
case value：  
语句；  
break；//可选   
default：//可选  
语句   
}   
##Java Number & Math类
所有包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类Number的子类  
Math的方法都被定义为static形式，通过Math类可以在主函数中直接调
###Number & Math类方法
* xxxValue() ：将Number对象转换为xxx数据类型的值并返回
* compareTo（）：将number对象与参数比较
* equals（）：判断number对象是否与参数相等
* valueOf（）：返回一个number对象指定的内置数据类型
* toString（）：以字符串形式返回值
* abs（）：返回参数的绝对值
* min()：返回两个参数最小
* max()：返回两个参数最大的
* pow（）：返回第一个参数的第二个参数次方
* sqrt（）：求参数的算术平方根
* random（）：返回一个随机数
##Java Character类
Character类用于对单个字符进行操作  
Character类在对象中包装一个基本类型char的值
###转义序列
前面有反斜杠\的字符代表转译字符。

* \t：插入tab键
* \b:插入退格键
* \n：该处换行
* \r：该处插入回车
* \'：该处插入单引号
* \\：该处插入\
###Character方法

* isLetter（）：是否是一个字母
* isDigit（）：是否是一个数字字符
* isWhitespace（）：是否是空格
* isUpperCase()：是否是大写字母
* isLowerCase（）：是否小写字母
* toUpperCase（）：指定字母的大写形式
* toLowerCase（）
* toString()：返回字符的字符串形式，字符串长度仅为1
##Java String类
###创建字符串
在java中字符串属于对象 ，Java提供了String类来创建和操作字符串 
String  name = "lily";  
String类有11中构造方法。这些方法提供不同的参数来初始化字符串。  
**注意：String类是不可改变的，一但创建了String对象，那它的值就无法改变了**
###字符串长度
用于获取有关对象的信息的方法称为访问器方法  
length（）：返回字符串对象包含的字符数
###连接字符串

* string1.concat（string2）；  返回string2连接string1的新字符串  
* “myname is”.concat("lily"); 也可以对字符串常量使用  
* "hello"+" world" 更常用的是用+连接
###String 方法

* char charAt（int index）：返回指定索引处的char值
* compareTo()方法
 * int compareTo（Object o）：字符串与对象比较。o是要比较的对象
 * int compareTo（String anotherString）：按字典顺序比较字符串  
返回值：  
  * 如果参数字符串等于次字符串，返回0
  * 如果此字符串小于字符串参数，则返回小于0的值
  * 如果此字符串大于字符串参数，则返回大于0的值
* boolean endWith（ String suffix）suffix指定的后缀：   
   String  str=new String("www.baidu.com");   
   boolean  ret=str.endsWith("com");
* boolean startsWith()
* boolean equals（Object anObject）：将次字符串与指定对象比较
* indexOf（）：返回指定字符在字符串中第一次出现的位置 。str.indexOf('a')
* lastIndexOf（）：返回指定字符在此字符串中最后一次出现处的索引。
* trim()：删除字符串的头尾空白。用法：str.trim()

##Java StringBuffer类和StringBuilder类
当对字符串进行修改时，会使用以上两个类。和String类不同，以上两个类的对象可以被多次修改，并且不产生新的未使用对象。  
两个不同在于StringBulider的方法没有是异步的，而StringBuffer的方法都是用synchronized修饰的同步方法（即StringBuffer不允许多线程同时访问）    
所以StringBuilder比StringBuffer有速度优势，大多数情况下建议使用StringBuilder类。  
但是在程序要求线程安全的情况下，则必须使用StringBuffer类  
###StringBuffer方法 

* public StringBuffer append(String s) ：将指定的字符追加到此字符序列
* public StringBuffer reverse（）：将此字符序列用其反转形式取代
* public delete（int start ，int end）：移除此序列的子字符串的字符
* public insert（int of ，int i）：将int参数的字符串表式形式插入此序列中
* replace （int start ，int end ，String str）：使用给定的String中的字符替换此序列的子字符串中的字符  

下面方法和String类的方法类似  

* int capacity()：返回当前容量
*  char charAT（int index）：返回此序列中指定索引处的char值
* int indexOf（String str）：返回第一次出现指定字符串在此字符串中的索引
* int indexOf（String str，int fromIndex）：从指定索引开始，返回指定字符串第一次出现的索引
* ing lastIndexOf（String str）：返回最后出现指定字符串位置
* int length（）：返回长度（字符数）
* String toString（）：返回此序列中数据的字符串表达式
##Java数组
###声明数组变量
必须先声明数组变量，才能在程序中使用数组
  
dataType[] 数组名；首选方法  
例：double[] myList;
###创建数组
变量名 = new dataType[arraySize]; 

* 使用dataType[arraySize]创建数组
* 把新创建的数组的引用赋值给变量  

数组变量声明和创建可以一起写：  
dataType[] 数组名= new dataType[arraySize];
###foreach循环
JDK5.1引用了一种新循环类型，被称为foreach循环或者加强循环，他能在不适用下标的情况下遍历数组  
###多维数组
多维数组可以看成是数组的数组。  
String str[] []=new String [3] [4];  //3行4列数组  
多维数组的动态初始化

* 直接为每一堆分配空间，格式如下：
type arrayName=new type[arraylength1] [arraylength2];  
* 从最高维开始，分别为每一维分配空间  
###Arrays类
java.util.Arrays类能方便操作数组，他提供的所有方法都是静态的  
具有以下功能：  

* 给数组赋值：通过fill方法  
  public static void fill()（int[] a,int val）  
* 对数组排序：通过sort方法。按升序  
  public static void sort(object[] a)
* 比较数组：通过equals  
  public static boolean equals(long[] a,long[] b)
* 查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找排序
##Java日期时间
java.util包提供了Date类来封装当前的日期时间。Date类提供两个构造函数类实例化Date对象。  


* 第一个构造函数使用当前日期和时间来初始化对象：Date（）
* 第二个构造函数接受一个参数，该参数是从1970年1月1日起的毫秒数 ：Date()
Date对象创建后，可以调用一下方法

* boolean after(Date date)：调用此方法的Date对象在指定日期之后返回true，否则false
* boolean before(Date date)
* Object clone()：返回此对象的副本
* int compareTo(Date date)：比较当调用此方法的Date对象和指定日期，相等返回0。调用对象在指定日期之前返回负数，之后返回正数
* boolean equals（Object date）：当调用此方法的Date对象和指定日期相等，返回true，不等返回false
* long getTime（）：返回自1970年1月1日以来此Date对象表示的毫秒
* void setTime(long time)：用毫秒数设置时间和日期
* String toString（）：转换Date对象为String表示形式，并返回该字符串
###获取当前日期
使用Date对象的toString方法
###使用SimpleDateFormat日期格式化
SimpleDateFormat是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat允许用户选择任意自定义的日期格式  
yyyy：完整的公元年    
MM:月份  
dd:日期  
hh：时。12小时制  
mm：分  
ss：秒  
HH：时。24小时制  
w：一年中第几周  
W：一月中第几周  
###使用printf格式化日期  
使用两个字母格式。以%t开头并且以下面一个字母结尾   

* c：包括全部日期和时间信息
* F："年-月-日"格式
* D：“月/日/年”格式
* r：12时制
* T：24时制
* R：“HH：mm”时分的24小时制 
###解析字符串为时间
SimlpeDateFormat类有一些附加方法，特别是parse（）
###Java休眠
sleep()使当前进程进入停滞状态（阻塞当前进程）。让出CPU的使用，目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行机会  
语法：Thread.sleep(秒数)
###Calendar类
Calendar类是一个抽象类，在实际使用时实现特定的子类对象，创建对象的过程对开发者是透明的，只需要使用getInsatace方法创建即可
####创建一个代表系统当前日期的Calendar对象
Calendar c=Calendar.getInatance();//默认是当前日期
####创建一个指定日期的Calendar对象
使用该类创建指定时间，需要首先创建一个Calendar对象，然后再设定该对象的年月日参数来完成  
//创建一个代表2017年5月8号的Calendar类  
Calendar c =Calendar.getInstance();   
c.set(2017,5,8) 
####Calendar类对象字段类型

* Calendar.YEAR(MONTH\DATE) ：年月日
* Calendar.HOUR：12小时制的小时
* Calendar.HOUR_OF_DAY：24小时制的小时
* Calendar.MINUTE(SECOND)：分钟、秒
* Calendar.DAY_OF_WEEK：星期几
####Calendar类对象信息设置

* Set设置  
  public final void set(int year,int month,int date)  
  c.set(2017,5,8)
  利用字段类型设置  
  如果只设定某个字段：  
  public void set（int field，int value）  
  例：将c的日期设置成10号 ：c.set(Calendar.DATE，10);  
* Add设置  
  把c对象的日期加上10 ：c.add(Calendar.DATE,10);  
  把c对象的日期减去10 ：c.add(Calendar.DATE,-10);
##Java正则表达式
正则表达式定义了字符串的模式  
正则表达式可以用来搜索、编辑、处理文本  
正则表达式并不仅限于某种语言，但是在每种语言中有细微的差距   
###正则表达式实例

* this is text：匹配字符串“this is text”
* this\s+is\s+text\s+：\s+表示可以匹配多个空格
* ^\d+(\.\d+)?：^表示以什么开头；\d+表示匹配一个或多个数字；\.表示匹配点；？设置括号内的选项是可选的
java.util.regex包主要包括一下三个类：

* Pattern类：pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为一个参数
* Matcher类：Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，它没有公共构造方法。需要调用Pattern对象的matcher方法来获得一个Matcher对象
* PatternSyntaxExpection： 是一个非强制异常类，它表示一个正则表达式模式中的语法错误
###正则表达式语法
* \：将下一个字符标记为特殊的字符等。如\n表示匹配换行符。\ \匹配\。 \ (匹配（
* ^：匹配以某个字符串开始的位置
* $：匹配输入字符串结尾的位置
* *：0次或多次匹配前面的字符或表达式
* +：匹配一次或多次匹配前面的字符或表达式
* ？：0次或一次匹配前面的字符或表达式。
* {n}：n为非负整数。正好匹配n次
* {n，}：至少匹配n次
* {n，m}:n<=m。至少匹配n次，最多匹配m次
* . ：匹配除\r\n之外的任何单个字符。
* x|y：匹配x或y
* [xyz]：字符集。匹配其中包含的任一字符
* [^xyz]：反向字符集。匹配不包含其中的任何字符
* [a-z]：匹配小写字母a到z
* [^a-z]：匹配不在指定范围内的字符
* \b：匹配一个字边界。如er\b匹配never中的er。但不匹配verb中的er
* \B：非字边界匹配。与上一个匹配相反
* \d：数字字符匹配。等效于[0-9]
* \D：非数字字符匹配。等效于[^0-9]
* \f：匹配换页符
* \n：换行符匹配
* \r：回车符匹配
* \t：制表符
* \v：垂直制表符匹配
* \s：匹配任何空白字符。与[\f\n\r\t\v]
* \S：匹配任何非空白字符
* \w：匹配任何字类字符，包括下划线。等效于[A-Za-z0-9]
* \W：与非单词字符匹配。等效于[^A-Za-z0-9]
###Matcher类的方法
####索引方法
索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配  

* public int start()：返回以前匹配的初始索引
* pubiic int start(int group)：返回在以前的匹配操作期间。由给定组所捕获的子序列的初始索引
* public int end()：返回最后匹配字符之后的偏移量
* public int end(int group)：返回在以前的匹配操作期间。由给定组所捕获子序列的最后字符之后的偏移量
####研究方法
研究方法用来检查输入字符串并返回一个布尔值。表示是否找到该模式  

* public boolean lookingAt()：尝试将从区域开头开始的输入序列与模式匹配
* public boolean find()：尝试查找与该模式匹配的输入序列的下一个子序列
* public boolean find(int start)：重置此匹配器。然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列
* public boolean matches()：尝试将整个区域与模式匹配
####替换方法
替换方法是替换输入字符串里文本的方法  

* public Matcher appendReplacement(StringBuffer sb,String replacement)：实现非终端添加和替换步骤
* public StringBuffer appendTail（StringBuffer sb）：实现终端添加和替换步骤
##Java方法
System.out.println()  

* println()是一个方法
* System是系统类
* out是标准输出对象
该语句的用法为，调用系统类System的标准输出对象out的printin（）方法
**方法命名规则**  
* 以大小写字母、下划线和$开头
* 可以包含数字，但是不能以数字开头
###方法的定义
修饰符  返回值类型  方法名 （参数类型 参数名）{  
方法体  
return 返回值;}

* 修饰符：可选。定义方法的访问类型（public static）
* 返回值类型：无返回值，用void
###方法重载
拥有相同方法名，但是参数列表不同（包括参数个数、不同参数名、不同参数类型）
###变量作用域
方法内定义的变量为局部变量。  
局部变量必须声明才可使用。  
其作用范围为声明开始，到包含的块结束
###构造方法
当一个对象被创建的时候，构造方法用来初始化该对象。  
构造方法和其所在类名相同，但构造方法没有返回值。  
通常会使用构造方法给一个类的实例变量赋初值。  
不管是否定义构造方法，所有类都有构造方法，因为java提供一个默认构造方法，它把所有成员初始化为0  
###finalize()方法
java允许定义这样的方法，它在对象被垃圾回收器回收之前调用。它用来清除回收对象
在finalize()方法中，必须指定在对象销毁时要执行的操作   
一般格式：  
protected void finalize（）{//这里终结代码}  
protected是一个限制符，它确保该方法不被该类以外的代码调用  
##Java 流（Stream）、文件（File）、IO
Java.io包几乎包含了所有操作输入、输出的类。所有这些流类代表了输入源和输出目标   
一个流可以理解为一个数据序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据  
###读取控制台输入  
Java的控制台输入由System.in完成  
为了获得一个绑定到控制台的字符流，可以把System.in包装在一个BufferedReader对象中来创建一个字符流
基本语法：  
**BufferedReader br=new BufferedReader(new InputStreamReader(System.in))**
BufferReader对象  
创建后，我们可以用read（）方法读取控制台的一个字符，或者用readLine（）读取一个字符串
###从控制台读取多字符输入
从BufferReader对象读取一个字符	要使用read（）方法，它的语法如下：  
int read（） throws IOException  
每次调用一次read（）方法，它从输入流中读取一个字符并以整型返回该数值。当流结束时返回-1。该方法抛出IOException
###控制台输出
控制台输出由print()和println()完成。这些方法都有类PrintStream定义，System.out是该类对象的一个引用      
PrintStream继承了OutputStream类，并且实现了方法write（）。所以，write（）也可以用来往控制台写操作  
最简单格式：void write(int byteval)  
该方法将byteval的低八位字节写到流中  
###FileInputStream
该流用于从文件中读取数据  
有多种构造方法可以用来创建对象：

* 可以使用字符串类型的文件名来创建一个输入流对象来读取文件：  
  InputStream f=new FileInputStream("C:/java/hello");
* 也可以使用一个文件对象来创建一个输入流对象来读取文件。首先使用File（）方法来创建一个文件对象  
  File f=new File("C:/java/hello");
  InputStream s=new FileInputStream(f);  

创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他流操作 

* public void close() throws IOException{}  
  关闭此文件输入流，并释放与此流有关的所有系统资源。抛出异常
* protected void finalize () throws IOException{}
  清除与该文件的连接。确保在不再引用文件输入流时调用其close方法
* public int read(int r) throws IOException{}
  从InputStream对象读取指定字节的数据。返回下一字节数据。如果到末尾返回-1
* public int read（byte[] r） throws IOException{}
  从输入流读取r.length长度的字节
* public int available() throws IOException{}
  从输入流读取的字节数
###FileOutputStream
该类用于创建文件并向文件写数据  
如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件   
有两个构造方法可以用来创建FileOutputStream对象   

* OutputStream f=new FileOutputStream("C:/java/hello");
* File f=new File("C:/java/hello");
  OutputStream o=new FileOutputStream(f);

创建了OUtputStream对象，就可以使用下面的方法来写入流或者进行其他流操作 

* public void write（）(int w) throws IOException{}
  把指定字节写到输出流中
* public viod write（byte[] r） 
  把指定数组中w.length长度的字节写到OutputStream中
###文件和I/O
还有一些关于文件和I/O的类：

* File Class
* FileReader Class
* FileWriter Class
###Java中的目录
####创建目录

* mkdir()：创建文件夹，成功返回true，失败返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能创建
* mkdirs()：创建一个文件夹和它所有父文件夹
####读取目录
一个目录就是一个File对象，它包含其他文件和文件夹  
如果创建一个File对象并且它是一个目录，那么调用isDirectory()方法返回true。  
可以通过调用该对象的list()方法，来提取它包含的文件和文件夹列表  
###删除目录或文件
删除文件可以使用java.io.File.delete()方法  
##Java Scanner类 
java.util.Scanner是Java5的新特性，可以通过Scanner类获取用户的输入  
Scanner s=new Scanner(System.in);  
###next()和nextLine()区别  
next()

* 一定要读取到有效字符后，才可以结束输入
* 对输入有效字符之前遇到的空白，next()会自动去掉
* 只有输入有效字符后，才将其后面输入的空白作为分隔符或者结束符
* next()不能得到带有空格的字符串  

nextLine()

* 以Enter为结束符，也就是说nextLine返回的是输入回车之前是所有字符
* 可以获得空白   
##Java异常处理
异常发生原因：  

* 输入非法数据
* 要打开的文件不存在
* 网络通信时连接中断，或者JVM内存溢出  
要理解Java异常处理是如何工作的，需掌握三种类型异常：

* 检查性异常：是用户错误或问题引起的异常，这是程序无法预见的。
* 运行时异常：是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略
* 错误：错误不是异常，而是脱离程序员控制的问题。错误在代码中经常被忽略。例如，当栈溢出时，一个错误就发生了。它们在编译时检查不到。
###Exception类的层次
所有异常类都是从java.lang.Exception类继承的子类  
Exception是Throwable的子类。除了Exception类外，Throwable还有一个子类Error。   
Java程序通常不捕获错误。错误一般发生在严重故障时，它们在java程序处理范围外  
Error用来指示运行时环境发生的错误。  
例如：JVM内存溢出。一般的，程序不会从错误中恢复  
异常类有两个主要的子类：IOException和RuntimeException  
Throwable ：Error  、Exception（：IOException、RuntimeException）
###Java内置异常类
Java语言定义了一些异常类在java.lang包中  
###异常方法
Throwable类的主要方法：  

* public String getMessage()：返回关于发生的异常的详细信息。
* public Throwable getCause()：返回一个Throwable对象代表异常原因 
* public String toString()：使用getMessage()的结果返回类的串级名称
* public void  printStackTrace()：打印toString()结果和栈层次到System.err，即错误输出流
* public StackTraceElement[] getStackTrace()：返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底
* public Throwable fillnStackTrace()：用当前的调用栈层次填充Throwable对象栈层次，添加到栈层次任何信息中
###捕获异常
try/catch代码块放在异常可能发生的地方  
语法：  
try{  
//程序代码  
}catch(ExceptionName e1)  
{//catch块  
}     
Catch语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try后面的catch块就会被检查  
如果发生的异常包含在catch块中，异常会被传递到该catch块，这和传递一个参数到方法一样  
###多重捕获块
一个try代码块后面跟着多个catch代码块叫做多重捕获  
###throw/throws关键字
如果一个方法没有捕获一个检查性异常，那么该刚发必须使用throws关键字声明。throws关键字放在方法签名的尾部   
也可以使用throw关键字抛出一个异常，无论它是新实例化的还是刚捕获的。  
一个方法可以声明抛出多个异常，多个异常之间用逗号隔开 
###finally关键字
finally关键字用来创建在try代码块后面执行的代码块  
无论是否发生异常，finally代码块中的代码总会被执行  
在finally代码块中，可以运行清理类型等收尾善后性质的语句  
finally代码块出现在catch代码块最后 
**注意事项**

* catch不能独立try存在
* 在try/catch后面添加finally并非强制性的
* try代码块后面不能既没有catch也没有finally 
* try、catch、finally块之间不能添加任何代码块    
###声明自定义异常
在java中可以自定义异常。编写自己的异常类时需要注意：

* 所有异常类都必须是Throwable的子类
* 如果希望写一个检查性异常类，则必须继承Exception
* 如果想写运行时异常类，那么需要继承RuntimeException类  
如： class MyException extends Exception{}  
只继承Exception类类创建的异常类是检查性异常类  
一个异常类和任何其他类一样，包含变量和方法  
###通用异常
在java中定义了两种类型的异常和错误：

* JVM（java虚拟机）异常：由JVM抛出的异常和错误。
* 程序级异常：有程序或者API程序抛出的异常。   
#Java面向对象
##Java继承
###继承的概念
继承就是子类继承父类的特征和行为。使得子类对象（实例）具有父类的实例域和方法，或子类继承父类方法，使得子类具有父类相同的方法  
###类的继承格式
class 父类{}  
class 子类 extends 父类{}
###继承的特性

* 子类拥有父类非private的属性和方法
* 子类可以拥有自己的属性和方法
* 子类可以用自己的方式实现父类的方法
* Java的继承是单继承，但是可以多重继承。单继承就是一个子类只能继承一个父类。多重继承就是，A类继承B类，B类继承C类，所以C类是B类的父类，B类是A的父类
* 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）
###继承的关键字
继承有两个关键字：extends和implements	。所有的类都是继承java.lang.Object，当一个类没有继承的两个关键字，则默认继承Object（这个类在java.lang包中，所以不需import）祖先类  

* **extends关键字**  
 在java中，类的继承是单一继承。即，一个子类只能拥有一个父类。所以extends只能继承一个类
* **implements 关键字**   
  使用implement可以变相的使java具有多继承的特性。使用范围为类继承接口的时候，可以同时继承多个接口。（接口和接口之间逗号隔开）
* **super和
* 关键字**
  * super：可以通过super关键字实现对父类成员的访问，用来引用当前对象的父类  
    可以调用父类的构造方法、方法。调用构造方法的语法：super()或super(参数)
  * this：指向自己的引用。表示当前对象
* **final关键字**
 final关键字声明类可以把类定义为不可继承的。即最终类；或者修饰方法，该方法不能被子类重写
 * 声明类：final class 类名{}
 * 声明方法：修饰符（public） final 返回值类型 方法名（）{}  
**注：**  被声明为final类的方法自动声明为final，但是实例变量并不是final
###构造器

* 子类不能继承父类的构造器（构造方法或者构造函数），但是**父类的构造器带有参数的，则必须在子类的构造器中显示的通过super关键字调用父类的构造器并配以适当的参数列表**。  
* 如果父类有无参构造器，则在子类中用super调用父类构造器不是必须的。如果没有使用super关键字，系统会自动调用父类的无参构造器  
* 调用父类方法，用super.父类方法名   
##Java重写（override）与重载（overload）
###重写（override）

* 重写是子类对父类允许访问的方法的实现过程进行重新编写，**返回值和形参都不能改变**。即**外壳不变，核心重写**  
* 重写的好处是子类可以根据需要，定义特定于自己的行为。即子类可以根据需要来实现父类的方法
* 重写方法不能抛出新的异常，或者是比被重写的方法更宽泛的异常，例如。父类的一个方法声明了IOException异常，其子类不能声明Exception异常，因为Exception是IOException的父类，只能抛出IOException的子类异常
###方法的重写规则

* **参数列表和返回类型必须完全与被重写方法的相同**
* 声明为final的方法不能被重写
* 声明为static的方法不能被重写。但是能被再次声明
* 访问权限不能比父类中被重写的方法的访问权限低。如，在父类中一个方法声明为public，在子类中该方法不能声明为private
* 构造方法不能被重写
###重载（overload）
重载是在一个类里面，方法名相同，参数不同（个数或类型）。返回类型可以相同可以不同  
每个重载方法（或者构造函数）都必须有一个独一无二的参数类型列表  
最常用的地方就是构造器的重载   
重载规则  

* 被重载的方法必须改变参数列表（参数个数、类型、顺序不一样）
* 被重载的方法可以改变返回值类型和访问修饰符
* 被重载的方法可以声明新的或更广的检查异常
* 方法可以在一个类中或子类中重载
##Java多态
多态是同一个行为具有多个不同表现形式或形态的能力  
多态就是同一个接口，使用不同的实例而执行不同操作  
多态性是对象多种表现形式的体现    
多态的优点：  

* 消除类型之间的耦合关系
* 可替换性
* 可扩充性
* 接口性
* 灵活性
* 简化性  

多态存在的必要条件

* 继承
* 重写
* 父类引用指向子类对象
  
如：Parent p=new Child();  
当使用多态方式调用方法时，首先检查父类是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法    
多态的好处：可以使程序由良好的扩展。并可以对所有类的对象进行通用处理  
###多态的实现方式
1. 重写：
2. 接口：
 * java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现
3. 抽象类和抽象方法
##java抽象类
###抽象类
由于抽象类不能实例化对象，所以必须被继承，才能使用。  
父类包含子类中常见的方法，但是父类是抽象的，所以不能使用这些方法  
在java中抽象类体现的是一种继承关系，一个类只能继承一个抽象类，但可以实现多个接口  
###抽象方法
抽象方法只包含方法名，没有方法体。  
抽象方法的具体实现由继承它的子类中实现  
public abstract 返回值类型 方法名();  

* 如果一个类包含抽象方法，那么该类必须为抽象类
* 任何子类必须重写父类的抽象方法，或者声明自身为抽象类
###抽象类总结规定

* 抽象类不能被实例化。只有抽象类的非抽象子类可以创建对象
* 抽象类中不一定包含抽象方法。但是，包好抽象方法的类一定是抽象类
* 抽象类中的抽象方法只是声明，不包含方法体。
* 构造方法，类方法（用static修饰的方法）不能声明为抽象方法
* 抽象类的子类必须给出抽象类中抽象方法的具体实现，除非该子类是抽象类

##Java封装
要访问该类的代码和数据，必须通过严格的接口控制  
封装的优点：  

* 良好的封装能够减少耦合
* 类内部的结构可以自由修改
* 可以对成员变量进行更精确的控制
* 隐藏信息，实现细节  

###实现封装的步骤
1. 修改属性的可见性来限制对属性的访问（一般限制为private）
2. 对每个值属性提供对外的公共访问方法，也就是创建一对赋取值方法，用于对私有属性的访问

##Java接口
* 接口：是一个抽象类型。是抽象方法等集合，接口通常以interface来声明。一个类通过继承接口等方式，来继承接口的抽象类  
* 接口并不是类，编写接口等方式和类很相似，但是两者是不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。
* 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法
* 接口无法被实例化，但是可以被实现。**一个实现接口的类，必须实现接口内所描述的所有方法**。  否则必须声明为抽象类。
* java中接口类型可以用来声明变量，他们可以成为空指针，或是被绑定在一个以此接口实现的对象
###接口与类相似点

* 一个接口可以有多个方法
* 接口文件保存在 .java结尾的文件中，文件名使用接口名
* 接口的字节码文件保存在 .class结尾的文件中
* 接口相应的字节码文件必须在与包名称相匹配的目录结构中
###接口与类的区别
* 接口不能用于实例化对象
* 接口没有构造方法
* **接口中所有的方法必须是抽象方法**
* 接口不能包含成员变量，除了static和final变量
* 接口不是被类继承，而是被类实现
* 接口支持多重继承
###接口特性

* 接口中每一个方法也是隐式抽象的，接口中的方法会被隐式的指定为public abstract（只能是public abstract，其他修饰符报错）
* 接口中可以含有变量，但是接口中的变量会被隐式的指定为public static final变量（只能是public修饰，用private修饰会报编译错误）
* 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法
###抽象类和接口的区别
* 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行
* 抽象类中的成员变量可以是各种类型的，而接口中的变量类型只能是public static final类型
* 接口中不能含有静态代码块和静态方法（static修饰的方法），而抽象类是可以有静态代码块和静态方法的
* 一个类只能继承一个抽象类，而一个类确可以实现多个接口
###接口的声明
格式：  
[可见度] interface 接口名 [extends 其他类]{}   
接口具有以下特征：  

*  接口是隐式抽象的，当声明一个接口时，不必使用abstract关键字
*  接口中的方法都是公有的
###接口的实现
* 当类实现接口的时候，类要实现接口中的所有方法。否则类必须声明为抽象类  
* 类使用implements关键字实现接口。在类声明中，该关键字放在class声明后面
* 实现接口的语法： ...implements 接口名称[,其他接口，其他接口...]  

重写接口中声明的方法时，需注意：

* 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制异常
* 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型
* 如果实现接口的类是抽象类，那么久没必要实现接口的方法

在实现接口时，也要注意一些规则：

* 一个类可以实现多个接口
* 一个类只能继承一个类，但是能实现多个接口
* 一个接口可以继承另一个接口，这和类之间的继承比较相似
###接口的继承
接口的继承也是使用extends关键字，子接口继承父接口的方法  
当一个接口继承另一接口时，不用重写父接口中的方法，因为子接口属于抽象
###接口的多重继承
在java中，类的多重继承是不合法的，但是接口允许多重继承  
public interface A extends B,C
###标记接口
最常用的继承接口是没有包含任何方法的接口  
标识接口是没有任何属性和方法的接口，它仅仅表明它的类属于一个特定的类型。供其他代码来测试允许做一些事情。  
标识接口作用： 简单形象的说就是给某个对象打个标，使对象拥有某些特权  
没有任何方法的接口被称为标记接口。标记接口主要用于：

* 建立一个公共的父接口
* 向一个类添加数据类型
##Java包
###包的作用

1. 把功能相似或相关的类或接口组织在一个包中，方便类的查找和使用
2. 如同文件夹一样，包也采用了树形目录的存储方式。同一包中的类名是不同的，不同包中类名可以相同，当同时调用两个不同包中的相同类名时，应该加上包名加以区别。
3. 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类

以下是一些java中的包：  

* java.lang 打包基础类
* java.io 包含输入输出功能的函数
###创建包

* 包声明应该在源文件的第一行，每个源文件只能有一个包声明
###import关键字
为了能够使用某个包的成员，我们需要在java程序中明确导入该包。  
在java源文件中，import语句应放在package语句之后，所有类声明之前，可以没有，可以有多个

#Java高级教程
##Java数据结构
java中的数据结构主要包括以下几种接口和类：  

* **枚举**（Enumerration）
* 位集合（Bitset）
* 向量（Vector）
* 栈（Stack）
* **Map**（Hashmap）
* **哈希表**（Hashtable）
* 属性（Properties）
###枚举
枚举接口本身虽不属于数据结构，但它在其他数据结构中应用很广。  
枚举接口定义了一种从数据结构中取回连续元素的方式  
枚举接口中定义了一些方法，通过这些方法可以枚举（一次获得一个）对象集合中的元素  
一些枚举声明的方法：

* boolean hasMoreElements()：测试此枚举是否包含更多元素
* Object nextElement（）：如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素

###位集合（BitSet）
位集合类实现了一组可以单独设置和清除的位或标志  
该类在处理一组布尔值时非常有用，你只需要给每个值赋值一位，然后对位进行适当的设置或清除，就可以对布尔进行操作了
###向量（Vector）
向量类和传统数组非常相似，但是Vector的大小可以根据需要动态的变化  
和数组一样，Vector对象的元素也能通过索引访问  
使用Vector类最主要的好处是，在创建对象时不必指定对象大小，它的大小会根据需要动态变化
###栈（Stack）
栈实现了一个后进先出的数据结构
###字典（Dictionary）（已过时）
* **字典类是一个抽象类**，用来存储键/值对，它定义了键映射到值的数据结构。作用和Map类似  
* 当想要通过特定的键而不是整数的索引来访问数据的时候，这时候应该使用Dictionary  
* 由于Dictionary是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现
* 给出键和值，就可以将值存储在Dictionary对象中。一旦该值被存储，就可以通过它的键来获取它。所以和Map一样，Dictionary也可以作为一个键/值对列表  

Dictionary定义的抽象方法：  

* Enumeration elements()：返回此Dictionary中值的枚举
* Object get(Object key)：返回此Dictionary中该键映射的值
* boolean isEmpty()：测试此Dictionary中是否存在键到值的映射
* Enumeration keys()：返回此Dictionary键的枚举
* Object put(Object key,Object value)：将指定key映射到此dictionary中指定value
* Object remove（Object key）：从dictionary中移除key（及其对应的value值）
* int size（）：返回此dictionary中条目（不同键）的数量
###Java Map接口
Map接口中键和值一一映射，可以通过键来获取值  

* 给定一个键和一个值，可以将该值存在Map对象中，之后，可以通过键来访问该值
* 当访问的值不存在时，方法就会抛出NoSuchElementException异常
* 当对象的类型和Map里元素类型不兼容时，就会抛出ClassCastException异常
* 当在不允许使用Null对象的Map中使用Null对象，会抛出NullPointer（指针）Exception异常
* 当尝试修改一个只读Map时，会抛出UnsupportedOperationException异常

常用方法：

* void clear（）：从此映射中移除所有映射关系
* boolean containsKey（Object k）：如果此映射包含指定键的映射关系，返回true
* boolean containsValue（Object v）：如果此映射将一个或多个键映射到指定值，返回true
* Set entrySet（）：返回此映射中包含的映射关系的set视图
* boolean equals（Object obj）：比较指定的对象与此映射是否相等
* Object get（Object k）：返回指定键所映射的值；如果此映射不包含该键的映射关系，返回null
* int hashCode（）：返回此映射的哈希码值
* booelan isEmpty（）：如果此映射为包好键-值映射关系，返回true
* Object put（Object k，Object v）：将指定的值与此映射中指定的键关联
* void putAll（Map m）：从指定映射中将所有映射关系复制到此映射中
* Object remove（Object k）：如果存在一个键的映射关系，则将其从此映射中移除
* int size（）：返回此映射中键-值映射关系
* Collection values（）：返回此映射中包含的值的Collection视图
###Java Hashtable接口
和HashMap一样，Hashtable在哈希表中存储键/值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值  
然后，该键经过哈希处理，所得到的散列码备用作存储在该表中值的索引  
Hashtable实现了Map接口。和HashMap类很相似，但是它支持同步  
Hashtable定义了四个构造方法:

1. 默认构造方法：Hashtable()
2. 创建指定大小的哈希表：Hashtable（int size）
3. 创建一个指定大小的哈希表，并且通过fillRatio指定填充比例
  填充比例必须介于0.0到1.0之间，它决定了哈希表在重新调整大小之前的充满程度：  
  Hashtable（int size ，float fillRatio）
4. 创建一个以M中元素为初始化元素的哈希表  
   哈希表的容量被设置为M的两倍：
   Hashtable（Map m）
###属性（Properties）
Properties继承于Hashtable.Properties类，表示了一个持久的属性集，属性列表中每个键及其对应值都是一个字符串

###链表
链表包括单向链表、双向链表、有序链表、无序链表、循环链表  
链表的顺序由各个对象里的指针决定。一般情况下，链表由节点（node）串联而成，而每个节点都有指向下一节点（next）或上一节点（previous）的指针（或引用）。对于特殊的两个节点，表头节点的上个节点，和表尾节点的下个节点均由null表示。除节点外，一个链表还应有一个表头指针（L.head）指向表头，表示遍历开始的地方。当表头指针指向null时，表示此链表为空
##Java集合框架
集合框架被设计成要满足一下目标：

* 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的
* 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性
* 对一个集合的扩展和适应必须是简单的  

为此，整个集合框架就围绕一组标准接口而设计  
集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包括以下内容：  

* 接口：是代表集合的抽象数据类型。接口允许集合独立操纵其代表的细节。接口通常形成一个层次。
* 实现（类）：是集合接口的具体实现。从本质上，它们是可重复使用的数据结构
* 算法：是实现集合接口对象里的方法执行的一些有用的计算。如，搜素和排序。这些算法被称为多态，因为相同的方法可以在相似接口上有不同的实现
###集合接口
集合框架定义了一些接口。

* Collection接口  
  Collection是最基本的集合接口，一个Collection代表一组Object，Java不提供直接继承自	Collection类。只提供继承于的子接口（如List和set）   
* List接口  
  List接口是一个有序的Collection，使用此接口可以精确的控制每个元素插入的位置，能够通过索引（元素在List中的位置，类似数组的小标）来访问List的元素，而且允许有相同元素
* Set  
  Set具有与Collection完全一样的接口。只是行为上不同，Set不保存重复的元素  
* SortedSet  
  继承于Set保存有序的集合
* Map   
  将唯一的键映射到值
* Map.Entry  
  描述在一个Map中一个元素（键/值对）。是一个Map的内部类
* SortedMap  
  继承于Map，使Key保持在升序排列
* Enumeration  
  这是一个传统的接口和定义方法。通过它可以枚举（一次获得一个）对象集合的元素。  

**Set和List区别**

* Set接口实例存储的是无序的，不重复的数据。List接口实例存储的是有序的，可以重复的元素
* Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置变化（实现类有HashSet,TreeSet）
* List和数组类似，可以动态增长，根据实际存储的数据长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素的位置改变（实现类有ArrayList，LinkedList，Vector）

###集合实现类（集合类） 
Java提供了一套实现Collection接口的标准集合类。其中一些是具体类，可以直接拿来使用，另外一些是抽象类，提供了接口的部分实现
标准集合类汇总表：  

* AbstractCollection：实现了大部分的集合接口  

**LIst:**

* AbstractList：继承上一类，并且实现了大部分List接口
* AbstractSequentialList： 继承上一类，提过了对数据元素链式访问而不是随机访问
* LinkedList：该类实现了List接口，允许有null（空）元素，主要用于创建链表数据结构，该类没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List的时候构造一个同步的List。如:
  Listlist=Collection.synchronizedList(newLinkedList(...))  
  LinkedList查找效率低
* ArrayList：该类也是实现了List接口，实现了可表大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的，在多线程 的情况下不要使用。ArrayList增长当前长度的50%，插入删除效率低
  
**Set：**  

* AbstractSet：继承于第一个类。并且实现了大部分Set接口
* HashSet：该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。
* LinkedHashSet：具有可预知迭代顺序的Set接口的哈希表和链接列表实现
* TreeSet：该类实现了Set接口，可以实现排序等功能 
  
**Map：**  

* AbstractMap：实现了大部分Map接口
* HashMap:是一个散列表。它存储的内容是键值对（key-value）映射
  该类实现了Map接口，格局键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步
* TreeMap：继承AbstractMap，并且使用一颗树
* WeakHashMap：使用弱秘钥的哈希表
* LinkedHashMap:继承于HashMap，使用元素的自然顺序对元素进行排序
* IdentityHashMap：继承于AbstractMap类，比较文档时使用引用相等


###集合算法
集合框架定义了几种算法，可用于集合和映射。这些算法被定义为集合类的静态方法  
在尝试比较不兼容的类型时，一些方法能抛出ClassCastException异常，当试图修改一个不可修改的集合时，抛出UnspportedOpertionException异常。  
集合定义三个静态的变量：empty_set,empty_list,empty_map。这些变量都不可改变  

* CollectionAlgorithms：这里是一个列表中所有算法的实现

###如何使用迭代器
迭代器：使你能够通过循环来得到或删除集合中的元素。ListIterator继承了Iterator，以允许双向遍历列表和修改元素  
迭代器方法描述：使用Java Iterator  
###如何使用比较器
TreeSet和TreeMap按照排序顺序来存储元素。这是通过比较器来精确定义按照什么样的排序顺序。这个接口可以让我们以不同方式来排序一个集合  
比较器方法描述： 使用Java Comparator  
###总结
集合是一个对象，可容纳其他对象的引用。
##Java泛型
Java泛型（generics）是JDK5中引入的特性，泛型提供了编译时类型安全监测机制。该机制允许程序员在编译时监测到非法的类型。  
**泛型的本质是参数化类型**。也就是所操作的数据类型被指定为一个参数。  
###泛型方法
你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当的处理每一个方法调用  
**定义泛型方法规则：**

* 所有泛型方法声明都有一个类型参数声明部分（由尖括号分割），**该类型参数声明在方法返回类型声明之前**
* 每个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符
* 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数的类型的占位符
* 泛型方法体的声明和其他方法一样。**注意类型参数只能代表引用类型，不能是原始类型（像int，double，char等）**  

###泛型类
泛型类和非泛型类声明类似，只是在类名后面添加了类型参数声明部分 

###类型通配符
1. 类型通配符一般是使用？代替具体的类型参数。例如List<?>在逻辑上是所有List<具体类型参数 >的父类
##Java序列化
Java提供了一种对象序列化机制，该机制中，一个对象可以被表示为一个字节序列。该字节序列包括该对象的数据，有关对象的类型信息和存储在对象中数据的类型
##Java网络编程
网络编程指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。  
java.net包提供了两种常见的网络协议支持：  

* TCP：TCP是传输控制协议的缩写，它保障了两个应用程序之间可靠通信。通常用于互联网协议，被称TCP/IP
* UDP:UDP用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据和数据包
###Socket编程
套接字使用TCP提供了两台计算机之间的通信机制。客户端程序创建一个套接字，并尝试连接服务器的套接字。  
当连接建立时，服务器会创建一个Socket对象。客户端和服务器之间可以通过对Socket对象的写入和读取来进行通信。  
java.net.Socket类代表一个套接字。并且java.util.ServerSocket类为服务器提供了一种监听客户端，并且他们建立连接的机制  
以下步骤在两台计算机之间使用套接字建立TCP连接时会出现：

* 服务器实例化一个ServerSocket对象，表示通过服务器上的端口通信
* 服务器调用ServerSocket类的accept()方法，该方法一直等待，知道客户端连接到服务器上给定的端口  
* 服务器正在等待时，一个客户端实例化一个Socket对象，指定服务器名称和端口号来请求连接
* Socket类的构造函数试图将客户端连接到指定的服务器和端口号，如果通信被建立，则在客户端建立一个Socket对象能够与服务器进行通信
* 在服务器端，accept()方法返回服务器上一个新的socket引用，该socket连接到客户端上的socket  

建立连接后，通过使用I/O流进行通信，每一个socket都有一个输入流和输出流，客户端的输出流连接到服务器上的输入流，而客户端的输入流连接到服务器上的输出流     
TCP是一个双向通信协议。因此数据可以通过两个数据流在同一时间发送。

#字符串格式化format
##对整数进行格式化：%[index$][标识][最小宽度]转换方式
* index：从1开始取值，表示将第index参数拿来参数化
* 最小宽度：最终该整数转化的位数
* 标识：
 * '-'：在最小宽度内左对齐，不可以与“用0填充”同时使用
 * '#'：只适用于8进制和16进制，8进制在结果前面增加一个0,16进制在结果前面加上0x
 * ' '：正值前加空格，负值前加负号
 * '0'：结果用0填充
 * ','：只是用于10进制，结果每3位用一个逗号隔开
 * '('：如参数是负数，则结果中不添加负号，而是用括号括起来

##单链表LinkedList  
基本概念  
1、 链表进行循环遍历效率低，但是插入和删除时优势明显。  
2、 单向链表是一种线性表，实际上是由节点node组成的。每个节点记录本节点的数据和下一个node。  
3、 添加节点的顺序是从右向左。最先添加的节点的下一节点的引用为空。  
4、 引用是引用下一节点的地址，而不是下一节点的对象，因为有着不断的引用，所有头结点就可以引用所有节点了  
5、 节点拥有两个成员：存储的对象和下一节点的引用
